"""Search orchestration for query generation, execution, and deduplication."""

import asyncio
import logging
from typing import List

from ai import get_agent
from clients import get_cosmos_client
from core.config import RETRIEVAL_TOP_K_PER_QUERY, RETRIEVAL_TIMEOUT_SECONDS
from core.exceptions import RetrieverError, StudioError
from core import Match


class Search:
    """Orchestrates document search: query generation, parallel execution, and deduplication."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.agent = get_agent()
        self.cosmos_client = get_cosmos_client()

    async def _generate_search_queries(
        self,
        section_name: str,
        section_description: str,
        template_description: str,
        project_description: str,
    ) -> List[str]:
        """Generate search queries using AI agent"""
        self.logger.info("Calling search agent")
        try:
            queries = await asyncio.wait_for(
                self.agent.plan_retrieval(
                    section_name,
                    section_description,
                    template_description,
                    project_description,
                ),
                timeout=RETRIEVAL_TIMEOUT_SECONDS / 3,
            )
        except asyncio.TimeoutError:
            self.logger.error("Timeout generating search queries")
            raise RetrieverError("Timeout generating search queries")
        except StudioError:
            raise
        except Exception as e:
            self.logger.error(f"Failed to generate search queries: {e}", exc_info=True)
            raise RetrieverError(f"Failed to generate search queries: {e}")

        if not queries:
            raise RetrieverError("No queries generated by agent")

        self.logger.info(f"[SEARCH] Generated {len(queries)} queries: {queries}")
        return queries

    async def _execute_search_queries(
        self, queries: List[str], file_ids: List[str]
    ) -> List[Match]:
        """Execute all search queries in parallel."""
        tasks = [self._execute_query(q, file_ids) for q in queries]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        all_matches: List[Match] = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                self.logger.warning(f"[SEARCH] Query {i} failed: {result}")
            elif isinstance(result, list):
                all_matches.extend(result)

        if not all_matches:
            raise RetrieverError("No matches retrieved from any query")

        return all_matches

    def _deduplicate(self, matches: List[Match]) -> List[Match]:
        """Remove duplicate matches by ID."""
        seen = set()
        unique = []
        for match in matches:
            if match.id not in seen:
                seen.add(match.id)
                unique.append(match)
        return unique

    async def _execute_query(self, query: str, file_ids: List[str]) -> List[Match]:
        """Execute a single search query."""
        try:
            return await asyncio.wait_for(
                self.cosmos_client.search(
                    query=query, file_ids=file_ids, top_k=RETRIEVAL_TOP_K_PER_QUERY
                ),
                timeout=RETRIEVAL_TIMEOUT_SECONDS / 4,
            )
        except asyncio.TimeoutError:
            self.logger.error(f"Timeout processing query: {query}")
            raise RetrieverError(f"Query timeout: {query}")
        except Exception as e:
            self.logger.error(f"Error processing query '{query}': {e}", exc_info=True)
            raise RetrieverError(f"Query failed: {e}")
